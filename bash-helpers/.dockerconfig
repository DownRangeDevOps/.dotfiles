# vim: set ft=sh:

# Alias
alias d="docker"
alias da="docker attach"
alias db="docker build"
alias dcm="docker commit"
alias dcp="docker cp"
alias dcr="docker create"
alias ddep="docker deploy"
alias dd="docker diff"
alias dev="docker events"
alias de="docker_exec"
alias dex="docker export"
alias dh="docker history"
alias di="docker image"
alias dim="docker import"
alias din="docker info"
alias dins="docker inspect"
alias dk="docker kill"
alias dld="docker load"
alias dlin="docker login"
alias dlout="docker logout"
alias dl="docker logs"
alias dn="docker network"
alias dp="docker pause"
alias dpt="docker port"
alias dps="docker_ps"
alias dpl="docker pull"
alias dpu="docker push"
alias drn="docker rename"
alias drst="docker restart"
alias drm="docker rm"
alias drmi="docker rmi"
alias dr="docker run"
alias ds="docker save"
alias dsr="docker search"
alias dst="docker start"
alias dsts="docker stats"
alias dstp="docker stop"
alias dtg="docker tag"
alias dt="docker top"
alias dunp="docker unpause"
alias dup="docker update"
alias dV="docker version"
alias dv="docker volume"
alias dw="docker wait"

# compose
alias dc="docker compose"

# convience functions
function dvrm() {
    volumes=$(docker volume ls \
        | awk '{if (NR!=1) {print $2}}' \
        | grep "${1:-.*}" --no-color)

    if [[ ${volumes} ]]; then
        printf_callout "Volumes to remove:"
        printf "%s\n" "${volumes}"
        prompt_to_continue "Delete volumes?" || return 0

        # User selected yes...
        for volume in $volumes; do
            docker volume rm "${volume}"
        done
    else
        printf_callout "No matching volumes found."
    fi
}

function docker_ps() {
    docker ps "${1:-}" | less -RSFX
}

# Search tags on docker hub
function search_docker_tags() {
  name=$1

  # Initial URL
  url="https://registry.hub.docker.com/v2/repositories/library/${name}/tags/?page_size=100"

  (
    # Keep looping until the variable URL is empty
    while [ -n "${url}" ]; do
        # Every iteration of the loop prints out a single dot to show progress as
        # it got through all the pages (this is inline dot)
        >&2 printf "%s" "."

        # Curl the URL and pipe the output to Python. Python will parse the JSON
        # and print the very first line as the next URL (it will leave it blank
        # if there are no more pages)
        #
        # then continue to loop over the results extracting only the name; all
        # will be stored in a variable called content
        content=$(curl -s "${url}" \
            | python -c "$(sed -E "s/^ *//" <(printf "%s" '
                    import sys, json; data = json.load(sys.stdin)
                    print(data.get("next", "") or "")
                    print("\n".join([x["name"] for x in data["results"]]))
            '))"
        )

      # Let's get the first line of content which contains the next URL for the
      # loop to continue
      url=$(printf "%s\n" "$content" | head -n 1)

      # Print the content without the first line (yes +2 is counter intuitive)
      printf "%s\n" "$content" | tail -n +2
    done;

    # Finally break the line of dots
    >&2 echo
  ) | cut -d '-' -f 1 | sort --version-sort | uniq;
}

function docker_exec() {
    if [[ $# -eq 0 || ${1} =~ 'help' ]]; then
        printf "%s\n" \
            "Docker helper to connect to a running container" \
            "    Usage: de <container> [<command>]"
        return 1
    else
        docker exec -ti "$@"
    fi
}
