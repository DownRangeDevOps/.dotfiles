# vim: set ft=sh:


# ------------------------------------------------
#  Healpers
# ------------------------------------------------
function __git_is_repo() {
    git -C "${1}" rev-parse 2>/dev/null
}

function git_master_or_main() {
    if ! __git_is_repo "${PWD}"; then
        printf "%s\n" "${PWD} is not a git repository."
        return 1
    fi

    INITIAL_COMMIT="$(git rev-list --abbrev-commit HEAD | tail -n 1)"

    git show-ref --verify --quiet refs/heads/master
    MASTER_EXISTS="${?}"

    git show-ref --verify --quiet refs/heads/main
    MAIN_EXISTS="${?}"

    if [[ -z ${MASTER_EXISTS} && -z ${MAIN_EXISTS} ]]; then
        MASTER_LENGTH="$(git rev-list --count "${INITIAL_COMMIT}..master")"
        MAIN_LENGTH="$(git rev-list --count "${INITIAL_COMMIT}..main")"

        if [[ ${MASTER_LENGTH} -gt ${MAIN_LENGTH} ]]; then
            MAIN_BRANCH="main"
        else
            MAIN_BRANCH="master"
        fi
    elif [[ ${MAIN_EXISTS} ]]; then
        MAIN_BRANCH="main"
    elif [[ ${MASTER_EXISTS} ]]; then
        MAIN_BRANCH="master"
    else
        printf "%s\n" "This repository does not have a 'master' or 'main' branch!"
        exit 1
    fi

    printf  "%s" "${MAIN_BRANCH}"
}

function gd() {
    git diff --color "${1:-@}" | diff-so-fancy | less --tabs=4 -RFX
}


# ------------------------------------------------
#  Alises
# ------------------------------------------------
alias g="git"
alias gs="git status"
alias gdm="gd origin/master..."
alias gdd="gd origin/develop..."
alias gd1="gd HEAD~"
alias gl="git log --graph --color --decorate=short --format=format:'%C(bold blue)%h%C(reset) -%C(auto)%d%C(reset) %C(white)%<(50,trunc)%s%C(reset) %C(black)[%an]%C(reset) %C(bold green)(%ar)%C(reset)' | LESS -SFX -R"
alias gl-="git log --graph --color --decorate=short --format=format:'%C(bold blue)%h%C(reset) -%C(auto)%d%C(reset) %C(white)%s%C(reset) %C(black)[%an]%C(reset) %C(bold green)(%ar)%C(reset)' | LESS -SFX -R"
alias gl--="git log --color --format=format:'â€¢ %C(white)%s%C(reset)' | LESS -SFX -R"
alias gL="git log --branches --remotes --graph --color --decorate=short --format=format:'%C(bold blue)%h%C(reset) -%C(auto)%d%C(reset) %C(white)%<(50,trunc)%s%C(reset) %C(black)[%an]%C(reset) %C(bold green)(%ar)%C(reset)' | LESS -SFX -R"
alias gL-="git log --branches --remotes --graph --color --decorate=short --format=format:'%C(bold blue)%h%C(reset) -%C(auto)%d%C(reset) %C(white)%s%C(reset) %C(black)[%an]%C(reset) %C(bold green)(%ar)%C(reset)' | LESS -SFX -R"
# alias lg2="git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(auto)%d%C(reset)%n''          %C(white)%s%C(reset) %C(dim white)- %an%C(reset)'"
# alias lg3="git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset) %C(bold cyan)(committed: %cD)%C(reset) %C(auto)%d%C(reset)%n''          %C(white)%s%C(reset)%n''          %C(dim white)- %an <%ae> %C(reset) %C(dim white)(committer: %cn <%ce>)%C(reset)'"
alias gstat="echo '==> Log: '\
    && git log origin/master.. \
    && echo '' && echo '==> Diff:' \
    && git diff --stat origin/master"
alias gstatd="echo '==> Log: '\
    && git log origin/develop.. \
    && echo '' && echo '==> Diff:' \
    && git diff --stat origin/develop"
alias gfu="git_fixup"

function git_fixup() {
    git add --update
    git log -n 50 --pretty=format:"%h %s" --no-merges \
        | fzf \
        | awk '{print $1}' \
        | xargs -o hub commit --fixup
    git rebase --interactive HEAD~2
}

# Branching
function gb() {
    if [[ $1 == "-D" ]]; then
        git branch "${@}"
    else
        git branch "${@}"| fzf
    fi
}

alias gbn="git rev-parse --abbrev-ref HEAD"
alias gba="git branch --all"
alias gf="git fetch --prune"
alias gp="gf && git pull --rebase"

function gco() {
    if [[ ${1} ]]; then
        git checkout "${@}"
    else
        git branch --all \
            | tr -d " " \
            | sed -e "s,^remotes/origin/,," \
            | sed -e "s,^HEAD.*,," \
            | sort -u \
            | fzf \
            | xargs git checkout
    fi
}

alias gcom="git checkout \$(git_master_or_main)"
alias gcod="git checkout develop"
alias gmerged="git branch --all --merged origin/\$(git_master_or_main) \
    | /usr/local/opt/grep/libexec/gnubin/grep -Ev '>|master|main|develop|release' \
    | tr -d ' '"
alias gdmb="git_delete_merged_branches"

function git_delete_merged_branches() {
    REMOTES="${*:-origin}"
    printf "%s\n" "==> Fetching updates..."
    git fetch --prune &>/dev/null
    git remote prune origin &>/dev/null

    CUR_BRANCH=$(git rev-parse --abbrev-ref HEAD)
    LOCAL_BRANCHES=$(gmerged \
        | /usr/local/opt/grep/libexec/gnubin/grep -Ev "^\s*remotes/origin/" \
        | /usr/local/opt/grep/libexec/gnubin/grep -Ev "${CUR_BRANCH}" \
        | awk '{print $1}')
    REMOTE_BRANCHES=$(gmerged \
        | /usr/local/opt/grep/libexec/gnubin/grep -E "^\s*remotes/origin/" \
        | sed -e "s/^\s*remotes\/origin\///g" \
        | awk '{print $1}')

    if [[ -n ${LOCAL_BRANCHES} || -n ${REMOTE_BRANCHES} ]]; then
        printf "%s\n" "==> Branches that have been merged to $(git_master_or_main):"
        gmerged

        prompt_to_continue "Delete branches?" || return 0
        echo

        if [[ -n ${LOCAL_BRANCHES} ]]; then
            printf "%s\n" "==> Deleting merged local branches..."
            git branch --delete --force ${LOCAL_BRANCHES}
        fi

        if [[ -n ${REMOTE_BRANCHES} ]]; then
            for REMOTE in ${REMOTES}; do
                printf  "%s\n" "==> Deleting merged remote branches from ${REMOTE}..."
                git push --delete "${REMOTE}" ${REMOTE_BRANCHES}
            done
        fi

        git fetch --prune &>/dev/null
        git remote prune origin &>/dev/null
        printf "%s\n" "==> Merged branches have been deleted..."
        printf "%s\n" "==> Everyone should run \`git fetch --prune\` to sync with this remote."
    else
        printf "%s\n" "==> No merged branches to delete."
    fi
}

# Committing
alias ga="git add"
alias ga.="git add --all"
alias gc="pre-commit run --all-files && git add --update && git commit --no-verify"
alias gst="git stash"
alias gcp="git cherry-pick -x"
alias gqf="ga -u && gc --amend --no-edit && gfpo"

# Rebasing
alias grb="git rebase --interactive"
alias grbc="git rebase --continue"
alias grba="git rebase --abort"
alias grbm="gf && git rebase --interactive origin/\$(git_master_or_main)"
alias grbd="gf && git rebase --interactive origin/develop"
alias grbs="gf && git rebase --interactive \$(git merge-base HEAD origin/\$(git_master_or_main))"

# Merging
alias gm=gmerge

# Pushing
alias gpu="git push -u \$(git remote) HEAD"
alias gfpo="git push --force-with-lease origin HEAD"

# Misc aliases for get based but non-git actions
alias gac="git diff origin/\$(git_master_or_main) \
    --stat \
    --diff-filter=ACdMRTUxB \
    !(roles.galaxy)"

# Add git completion
add_git_completion_to_aliases() {
    declare -f -F __git_complete > /dev/null
    if [[ -n $? ]]; then
        __git_complete gco _git_checkout
        __git_complete ga _git_add
        __git_complete gb _git_branch
        __git_complete gst _git_stash
        __git_complete grb _git_rebase
    fi
}
add_git_completion_to_aliases

__git_wrap_gffm() {
    declare -f -F __git_func_wrap > /dev/null
    if [[ -n $? ]]; then
        __git_func_wrap _git_merge
    fi
}
complete -o bashdefault -o default -o nospace -F __git_wrap_gffm gffm

__git_wrap_gnuke() {
    declare -f -F __git_func_wrap > /dev/null
    if [[ -n $? ]]; then
        __git_func_wrap _git_checkout
    fi
}
complete -o bashdefault -o default -o nospace -F __git_wrap_gnuke gnuke

# Functions
#
# TODO: accept ticket id and call assembla API for title
# Auto branch w/ ticket name
# gco -b rf/pipeline/$(echo '#7369 - Create a local docker test environment for build' | tr -d '#' | tr -s ' ' '-' | tr [:upper:] [:lower:])
gcot() {
  TICKET=$(echo "${@}" \
    | tr -t "${@}" 50 \
    | sed "s/^[\.\/]//" \
    | tr -s " " "-" \
    | tr -cd "[:alnum:]._-/" \
    | tr "[:upper:]" "[:lower:]")

  gco -b "${TICKET}"
}

# git merge --ff-only
gmerge() {
    MAIN_BRANCH=$(git_master_or_main)

    if [[ $1 == "--ff-only" ]]; then
        MERGE_COMMIT_OPTION="--ff-only"
        shift
    else
        MERGE_COMMIT_OPTION="--no-ff"
    fi

    if [[ $1 == "help" || $1 == "--help" ]]; then
        print  "%s\n" \
            "Usage: gffm [OPTION] [<BRANCH>]" \
            "Merge BRANCH to ${MAIN_BRANCH} printing the log and stat, and" \
            "prompting before merging or pushing." \
            "" \
            "If no BRANCH, or BRANCH is HEAD, the current branch will be merged to ${MAIN_BRANCH}."
    else
        if [[ $1 == "HEAD" || $1 == "" ]]; then
            git log "origin/${MAIN_BRANCH}.."
            git diff --stat "origin/${MAIN_BRANCH}"
            prompt_to_continue "Merge to ${MAIN_BRANCH}?"

            printf "%s\n" "==> Updating from origin..."
            git fetch -p

            printf "%s\n" "==> Rebasing on ${MAIN_BRANCH}..."
            git checkout "${MAIN_BRANCH}"
            git pull -r
            git rebase "origin/${MAIN_BRANCH}"

            printf "%s\n" "==> Merging to ${MAIN_BRANCH}..."
            git merge "${MERGE_COMMIT_OPTION}" "@{-1}"
            prompt_to_continue "Push to origin?"

            printf "%s\n" "==> Pushing ${MAIN_BRANCH}..."
            git push origin HEAD
        else
            BRANCH=$1
            git checkout "${BRANCH}"

            printf "%s\n" "==> Updating ${BRANCH}..."
            git fetch -p
            git pull -r
            git checkout "@{-1}"
            git log "${BRANCH}..@"
            git diff --stat "${BRANCH}"
            prompt_to_continue "Merge to ${BRANCH}?"

            printf "%s\n" "==> Merging to ${BRANCH}..."
            git rebase "${BRANCH}"
            git checkout "${BRANCH}"
            git merge "${MERGE_COMMIT_OPTION}" "@{-1}"
            prompt_to_continue "Push to origin?"

            printf "%s\n" "==> PUshing ${BRANCH}..."
            git push origin HEAD
        fi
    fi
}

# git commit and push
gcpu() {
    if [[ $1 == "help" || $1 == "--help" ]]; then
        echo "Optionally adds all unstaged changes, commits, and pushes to origin"
        echo "Usage: gacp [-a] [-m <message>]"
        return 1
    fi

    BRANCH=$(git rev-parse --abbrev-ref HEAD)
    COMMAND=""

    if [[ $1 == "-a" ]]; then
        COMMAND="git add --all && "
        shift
    fi

    if [[ $1 == "-m" && $2 ]]; then
        COMMAND+="git commit -m '$2' && "
    else
        COMMAND+="git commit && "
    fi

    COMMAND+="git push origin $BRANCH"

    $COMMAND
}

# delete local and remote branch
gnuke() {
    if [[ $# -eq 0 || $1 == "help" || $1 == "--help" ]]; then
        echo "Usage: gnuke <branch>"
        return 1
    fi

    git remote | xargs -L1 -I remote git push --delete remote "$@" 2>/dev/null
    git branch -D "$@" 2>/dev/null
}

# delete current branch and it's remote
gnukethis() {
    BRANCH=$(git rev-parse --abbrev-ref HEAD)

    git remote | xargs -L1 -I remote git push --delete remote "${BRANCH}"
    git branch -D "${BRANCH}"
}

# git log copy - copy the git log for this branch to the clipboard
glc() {
    # shellcheck disable=SC2046
    LOG="$(git log \"origin/$(git_master_or_main)..HEAD\")"

  pbcopy <<EOF

\`\`\`
${LOG}
\`\`\`
EOF
}

# [o]pen [p]ull [r]equest - open a pull request for the current branch
# Real URL example: https://gitlab.com/sightly-engineering/content-intelligence/api-cont-intell-user-account/-/merge_requests/new?merge_request%5Bsource_branch%5D=feature%2Frf%2FEN-4597--docker-add-health-check
opr() {
    REPO=$(basename "$(git rev-parse --show-toplevel)")
    BRANCH=$(git rev-parse --abbrev-ref HEAD)
    BRANCH_ENCODED=$(python3 -c "from urllib.parse import quote_plus; import json;s=quote_plus(json.dumps(\"${BRANCH}\"));print(s)")
    HOST="https://gitlab.com/sightly-engineering"
    ROUTE="${REPO}/-/merge_requests/new"
    QUERY="utf8=%E2%9C%93&merge_request%5Bsource_project_id%5D=21762811&merge_request%5Bsource_branch%5D=${BRANCH_ENCODED}&merge_request%5Btarget_project_id%5D=21762811&merge_request%5Btarget_branch%5D=$(git_master_or_main)"

    glc
    open "${HOST}/${ROUTE}?${QUERY}"
}
