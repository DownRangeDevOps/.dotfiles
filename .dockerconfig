# vim: set ft=sh:
export COMPOSE_HTTP_TIMEOUT=999999

# Alias
alias d='docker'
alias di='docker image'
alias dr='docker run'
alias dstp='docker stop'
alias dst='docker start'
alias dv='docker volume'

dps() {
    docker ps ${1:-}| less -RSFX
}

# Start measurabl
alias dcm="docker-compose -f ~/dev/measurabl/src/docker/docker-compose.yml $@"

# Search tags on docker hub
function docker-tags () {
  name=$1
  # Initial URL
  url=https://registry.hub.docker.com/v2/repositories/library/$name/tags/?page_size=100
  (
    # Keep looping until the variable URL is empty
    while [ ! -z $url ]; do
      # Every iteration of the loop prints out a single dot to show progress as it got through all the pages (this is inline dot)
      >&2 echo -n "."
      # Curl the URL and pipe the output to Python. Python will parse the JSON and print the very first line as the next URL (it will leave it blank if there are no more pages)
      # then continue to loop over the results extracting only the name; all will be stored in a variable called content
      content=$(curl -s $url | python -c 'import sys, json; data = json.load(sys.stdin); print(data.get("next", "") or ""); print("\n".join([x["name"] for x in data["results"]]))')
      # Let's get the first line of content which contains the next URL for the loop to continue
      url=$(echo "$content" | head -n 1)
      # Print the content without the first line (yes +2 is counter intuitive)
      echo "$content" | tail -n +2
    done;
    # Finally break the line of dots
    >&2 echo
  ) | cut -d '-' -f 1 | sort --version-sort | uniq;
}

# Docker shortcuts
dc() {
  docker-compose ${@}
  # if [[ ${#} -eq 2 ]]; then
  #   if [[ -z $(docker ps --quiet --filter "name=${1}") ]]; then
  #     case ${2} in
  #       'bash')
  #           docker-compose exec ${1} bash;;
  #       'sh')
  #           docker-compose exec ${1} sh;;
  #       'logs')
  #           docker-compose logs -f ${1};;
  #         *)
  #           docker-compose "${@}";;
  #     esac
  #   else
  #     docker-compose "${@}"
  #   fi
  # else
  #   case ${1} in
  #     'up')
  #         docker-compose up -d ${@};;
  #     'logs')
  #       docker-compose logs -f "${@:2}";;
  #     'bash')
  #       docker-compose exec "${@:2}" bash;;
  #     *)
  #       docker-compose "${@}";;
  #   esac
  # fi
}

dm() {
  if [[ $# -eq 1 ]]; then
    case $1 in
      *)
        docker-machine "$@";;
    esac
  else
    docker-machine "$@"
  fi
}

dme() {
  if [[ $# -eq 0 ]]; then
    echo 'Usage: dme <docker-machine name>'
    return 1
  fi

  MACHINE=$1
  AVAILABLE_MACHINES=($(docker-machine ls -q))

  if [[ $(echo ${AVAILABLE_MACHINES[@]} | grep -x ${MACHINE} | wc -w) ]]; then
    eval $(docker-machine env $MACHINE)
    echo "==> ${MACHINE} configured for this session"
  else
    echo "${MACHINE} isn't available. Available docker-machine's:"
    printf '%s\n' "${AVAILABLE_MACHINES[@]}"
  fi
}

de() {
  if [[ $# -eq 0 || ${1} =~ 'help' ]]; then
    echo 'Docker helper to connect to a running container'
    echo 'Usage: de <container> [<command>]'
    return 1
  fi

  docker exec -ti $@ 2>/dev/null || docker exec -ti $@ /bin/bash
}
