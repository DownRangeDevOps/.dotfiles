# vim: set ft=bash:
alias g="git"

# Logging
function gd() {
    git diff --color "${1:-@}" | diff-so-fancy | less --tabs=4 -RFX
}

alias gs="git status"
alias gdm="gd origin/master"
alias gdmh="gd origin/master..HEAD"
alias gdd="gd origin/develop"
alias gddh="gd origin/develop..HEAD"
alias gdm="gd origin/master"
alias gd1="gd HEAD~"
alias gl="git log --graph --color --decorate=short --format=format:'%C(bold blue)%h%C(reset) -%C(auto)%d%C(reset) %C(white)%<(50,trunc)%s%C(reset) %C(black)[%an]%C(reset) %C(bold green)(%ar)%C(reset)' | LESS -SFX -R"
alias gl-="git log --graph --color --decorate=short --format=format:'%C(bold blue)%h%C(reset) -%C(auto)%d%C(reset) %C(white)%s%C(reset) %C(black)[%an]%C(reset) %C(bold green)(%ar)%C(reset)' | LESS -SFX -R"
alias gl--="git log --color --format=format:'â€¢ %C(white)%s%C(reset)' | LESS -SFX -R"
alias gL="git log --branches --remotes --graph --color --decorate=short --format=format:'%C(bold blue)%h%C(reset) -%C(auto)%d%C(reset) %C(white)%<(50,trunc)%s%C(reset) %C(black)[%an]%C(reset) %C(bold green)(%ar)%C(reset)' | LESS -SFX -R"
alias gL-="git log --branches --remotes --graph --color --decorate=short --format=format:'%C(bold blue)%h%C(reset) -%C(auto)%d%C(reset) %C(white)%s%C(reset) %C(black)[%an]%C(reset) %C(bold green)(%ar)%C(reset)' | LESS -SFX -R"
# alias lg2="git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(auto)%d%C(reset)%n''          %C(white)%s%C(reset) %C(dim white)- %an%C(reset)'"
# alias lg3="git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset) %C(bold cyan)(committed: %cD)%C(reset) %C(auto)%d%C(reset)%n''          %C(white)%s%C(reset)%n''          %C(dim white)- %an <%ae> %C(reset) %C(dim white)(committer: %cn <%ce>)%C(reset)'"
alias gstat="echo '==> Log: '\
    && git log origin/master.. \
    && echo '' && echo '==> Diff:' \
    && git diff --stat origin/master"
alias gstatd="echo '==> Log: '\
    && git log origin/develop.. \
    && echo '' && echo '==> Diff:' \
    && git diff --stat origin/develop"

# Branching
function gb() {
    git branch "${@}"| fzf
}
alias gbn="git rev-parse --abbrev-ref HEAD"
alias gba="git branch --all"
alias gf="git fetch --prune"
alias gp="gf && git pull --rebase"
function gco() {
    if [[ ${1} ]]; then
        git checkout "${@}"
    else
        git branch -a \
            | tr -d ' ' \
            | sed -e 's,^remotes/origin/,,' \
            | sed -e 's,^HEAD.*,,' \
            | sort \
            | uniq \
            | fzf \
            | xargs git checkout
    fi
}

alias gcom="git checkout master"
alias gcod="git checkout develop"
alias gmerged="git branch --all --merged origin/master \
    | /usr/local/opt/grep/libexec/gnubin/grep -Ev '>|master|develop|release' \
    | tr -d ' '"
alias gdmb="git_delete_merged_branches"

function git_delete_merged_branches() {
    REMOTES="${*:-origin}"
    printf "%s\n" "==> Fetching updates..."
    git fetch --prune &>/dev/null
    git remote prune origin &>/dev/null

    CUR_BRANCH=$(git rev-parse --abbrev-ref HEAD)
    LOCAL_BRANCHES=$(gmerged \
        | /usr/local/opt/grep/libexec/gnubin/grep -Ev '^\s*remotes/origin/' \
        | /usr/local/opt/grep/libexec/gnubin/grep -Ev "${CUR_BRANCH}" \
        | awk '{print $1}')
    REMOTE_BRANCHES=$(gmerged \
        | /usr/local/opt/grep/libexec/gnubin/grep -E '^\s*remotes/origin/' \
        | sed -e 's/^\s*remotes\/origin\///g' \
        | awk '{print $1}')

    if [[ -n ${LOCAL_BRANCHES} || -n ${REMOTE_BRANCHES} ]]; then
        printf "%s\n" "==> Branches that have been merged to master:"
        gmerged

        prompt_to_continue 'Delete branches?' || return 0
        echo

        if [[ -n ${LOCAL_BRANCHES} ]]; then
            printf "%s\n" "==> Deleting merged local branches..."
            git branch --delete ${LOCAL_BRANCHES}
        fi

        if [[ -n ${REMOTE_BRANCHES} ]]; then
            for REMOTE in ${REMOTES}; do
                printf  "%s\n" "==> Deleting merged remote branches from ${REMOTE}..."
                git push --delete "${REMOTE}" ${REMOTE_BRANCHES}
            done
        fi

        git fetch --prune &>/dev/null
        git remote prune origin &>/dev/null
        printf "%s\n" "==> Merged branches have been deleted..."
        printf "%s\n" "==> Everyone should run \`git fetch --prune\` to sync with this remote."
    else
        printf "%s\n" "==> No merged branches to delete."
    fi
}

# Committing
alias ga="git add"
alias ga.="git add --all"
alias gc="git commit"
alias gst="git stash"
alias gcp="git cherry-pick -x"
alias gqf="ga. && gc --amend --no-edit && gfpo"

# Rebasing
alias grb="git rebase --interactive"
alias grbc="git rebase --continue"
alias grba="git rebase --abort"
alias grbm="gf && git rebase --interactive origin/master"
alias grbd="gf && git rebase --interactive origin/develop"

# Pushing
alias gpu="git push -u \$(git remote) HEAD"
alias gfpo="git push --force-with-lease origin HEAD"

# Misc aliases for get based but non-git actions
alias gac="git diff origin/master \
    --stat \
    --diff-filter=ACdMRTUxB \
    !(roles.galaxy)"

# Add git completion
add_git_completion_to_aliases() {
    declare -f -F __git_complete > /dev/null
    if [[ -n $? ]]; then
        __git_complete gco _git_checkout
        __git_complete ga _git_add
        __git_complete gb _git_branch
        __git_complete gst _git_stash
        __git_complete grb _git_rebase
    fi
}
add_git_completion_to_aliases

__git_wrap_gffm() {
    declare -f -F __git_func_wrap > /dev/null
    if [[ -n $? ]]; then
        __git_func_wrap _git_merge
    fi
}
complete -o bashdefault -o default -o nospace -F __git_wrap_gffm gffm

__git_wrap_gnuke() {
    declare -f -F __git_func_wrap > /dev/null
    if [[ -n $? ]]; then
        __git_func_wrap _git_checkout
    fi
}
complete -o bashdefault -o default -o nospace -F __git_wrap_gnuke gnuke

# Functions
#
# TODO: accept ticket id and call assembla API for title
# Auto branch w/ ticket name
# gco -b rf/pipeline/$(echo '#7369 - Create a local docker test environment for build' | tr -d '#' | tr -s ' ' '-' | tr [:upper:] [:lower:])
gcot() {
  TICKET=$(echo "${@}" \
    | tr -t "${@}" 50 \
    | sed 's/^[\.\/]//' \
    | tr -s ' ' '-' \
    | tr -cd '[:alnum:]._-/' \
    | tr "[:upper:]" "[:lower:]")

  gco -b "${TICKET}"
}

# git merge --ff-only
gffm() {
    if [[ $1 == 'help' || $1 == '--help' ]]; then
        echo "Usage: gffm <branch>"
        return 1
    fi

    if [[ $1 == 'HEAD' || $1 == '' ]]; then
        git log origin/master.. && \
        git diff --stat origin/master && \
        prompt_to_continue 'Merge to master?' && \
        git checkout master && \
        git fetch -p && \
        git pull -r && \
        git merge --ff-only @{-1} && \
        prompt_to_continue 'Push to origin?' && \
        git push origin HEAD
    else
        BRANCH=$1
        git log @{-1}.."${BRANCH}" && \
        git diff --stat origin/master && \
        prompt_to_continue "Merge to ${1}?" && \
        git merge --ff-only "$BRANCH" && \
        prompt_to_continue 'Push to origin?' && \
        git push origin HEAD
    fi

}

# git commit and push
gcpu() {
    if [[ $1 == 'help' || $1 == '--help' ]]; then
        echo "Optionally adds all unstaged changes, commits, and pushes to origin"
        echo "Usage: gacp [-a] [-m <message>]"
        return 1
    fi

    BRANCH=$(git rev-parse --abbrev-ref HEAD)
    COMMAND=''

    if [[ $1 == '-a' ]]; then
        COMMAND="git add --all && "
        shift
    fi

    if [[ $1 == '-m' && $2 ]]; then
        COMMAND+="git commit -m '$2' && "
    else
        COMMAND+="git commit && "
    fi

    COMMAND+="git push origin $BRANCH"

    $COMMAND
}

# delete local and remote branch
gnuke() {
    if [[ $# -eq 0 || $1 == 'help' || $1 == '--help' ]]; then
        echo "Usage: gnuke <branch>"
        return 1
    fi

    git remote | xargs -L1 -I remote git push --delete remote "$@" 2>/dev/null
    git branch -D "$@" 2>/dev/null
}

# delete current branch and it's remote
gnukethis() {
    BRANCH=$(git rev-parse --abbrev-ref HEAD)

    git remote | xargs -L1 -I remote git push --delete remote "${BRANCH}"
    git branch -D "${BRANCH}"
}

# git log copy - copy the git log for this branch to the clipboard
glc() {
  LOG=$(git log origin/master..HEAD)

  pbcopy <<EOF

\`\`\`
${LOG}
\`\`\`
EOF
}

# [o]pen [p]ull [r]equest - open a pull request for the current branch
opr() {
    REPO=$(basename "$(git rev-parse --show-toplevel)")

    BRANCH=$(git rev-parse --abbrev-ref HEAD)
    TITLE=$(git log -n1 --pretty=format:'%s')
    BRANCH_ENCODED=$(python3 -c "from urllib.parse import quote_plus; import json;s=quote_plus(json.dumps(\"${BRANCH}\"));print(s)")
    TITLE_ENCODED=$(python3 -c "from urllib.parse import quote_plus; import json;s=quote_plus(json.dumps(\"${TITLE}\"));print(s)")

    HOST="https://bitbucket.org/measurabl"
    ROUTE="${REPO}/pull-requests/new"
    QUERY="source=${BRANCH_ENCODED}&t=${TITLE_ENCODED}"

    glc
    open "${HOST}/${ROUTE}?${QUERY}"
}
